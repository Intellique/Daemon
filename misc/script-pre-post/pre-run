Job:
* backup db:
  - pre: {
    'send': {
      'backup': {
        'database': {
          'name': string, // nom du pilote de la base de données
        }, // information concernant la base de données
      }, // information concernat la sauvegarde
    },
    'received': {
        'data': { }, // données passées to job
        'message': string, // optionel, message à insérer dans les logs
        'should run': bool, // false si on ne doit pas exécuter la tâche
    },
  }
  - post: {
    'send': {
      'backup': {
        'database': {
          'name': string, // nom du pilote de la base de données
        }, // information concernant la base de données
        'timestamp': integer, // nombre de seconde écoulé depuis l'Epoch
        'nb medias': integer, // nombre de médias connus au moment de sauvegarder la base de données
        'nb archives': integer, // nombre d'archives faites au momen de sauvegarde la base de données
        'volumes': [ {
          'media': {
            'uuid': string, // l'identifiant unique du média
            'label': string ou null, // label du média si connu ou valeur nulle
            'name': string, // nom du média défini par l'utilisateur
          },
          'position': integer, // position du volume sur le média
        }, ... ], // volumes d'une sauvegarde
        'nb volumes': integer, // nombres de volumes
      }, // information concernat la sauvegarde
    },
    'received': {
    }
  }
  - on error:
* check-archive:
  - pre: {
    'send': {
    },
    'received': {
        'data': { // données passées to job
        },
        'message': string, // optionel, message à insérer dans les logs
        'should run': bool, // false si on ne doit pas exécuter la tâche
    },
  }
  - post:
  - on error:
* copy-archive:
  - pre: {
    'send': {
    },
    'received': {
        'data': { // données passées to job
        },
        'message': string, // optionel, message à insérer dans les logs
        'should run': bool, // false si on ne doit pas exécuter la tâche
    },
  }
  - post:
  - on error:
* create-archive:
  - pre: {
    'send': {
        'archive name': string, // nom de l'archive par défaut
        'paths': [ string, ... ], // liste des chemins des fichiers à archiver
        'pool': {
            'name': string, // nom du pool
            'uuid': string, // l'identifiant unique du pool
        }, // information du pool
    },
    'received': {
        'data': { // données passées to job
            'archive': {
                'name': string, // optionel, nom de l'archive si différente du nom originel
                'uuid': string, // optionel, l'identifiant unique qui est utilisé à la place d'un généré par le démon
            }
        },
        'message': string, // optionel, message à insérer dans les logs
        'should run': bool, // false si on ne doit pas exécuter la tâche
    },
  }
  - post: {
    'send': {
        'archive': {
            'name': string, // nom de l'archive faite
            'creator': string, // login de l'utilisateur qui a créé l'archive
            'size': integer, // taille de l'archive en octet
            'volumes': [ {
                'sequence': integer, // position du volume dans l'archive
                'size': integer, // taille du volume en octet
                'start time': integer, // l'heure de création du volume, en seconde depuis l'Epoch
                'end time': integer, // l'heure de fin de création du volume, en seconde depuis l'Epoch
                'checksum': {
                    'key': 'value', ... // 'key' correspond à l'algorithme utilisé et 'value' à l'empreinte calculé
                }, // empreintes du volumes calculées lors de l'archivage
                'files': [ {
                    'name': string, // chemin complet du fichier lors de l'archivage
                    'type': string, // type du fichier (répertoire, ...)
                    'mime type': string, // type mime identique à 'file -i filename'
                    'owner id': integer, // uid du fichier
                    'owner': string, // propriétaire du fichier
                    'group id': integer, // gid du fichier
                    'group': string, // groupe du fichier
                    'perm': string, // permission du fichier
                    'size': integer, // taille du fichier
                }, ... ], // liste des fichiers présent dans le volume
                'media': {
                    'uuid': string, // l'identifiant unique du média
                    'label': string ou null, // label du média si connu ou valeur nulle
                    'name': string, // nom du média défini par l'utilisateur
                }, // information concernant le média
                'media position': integer, // position du fichier dans le média
            }, ... ], // informations concernant les volumes de l'archive
        }, // information de l'archive
    },
    'received': {
    }
  }
  - on error:
* format-media:
  - pre: {
    'send': {
    },
    'received': {
        'data': { // données passées to job
        },
        'message': string, // optionel, message à insérer dans les logs
        'should run': bool, // false si on ne doit pas exécuter la tâche
    },
  }
  - post:
  - on error:
* restore-archive:
  - pre: {
    'send': {
    },
    'received': {
        'data': { // données passées to job
        },
        'message': string, // optionel, message à insérer dans les logs
        'should run': bool, // false si on ne doit pas exécuter la tâche
    },
  }
  - post:
  - on error:
